/**\n * Transit Tracking Engine\n * Real-time planetary movements and their effects on natal charts\n */\n\nimport {\n  BirthChart,\n  Transit,\n  Planet,\n  AspectType,\n  PlanetaryPosition,\n  CalculationResult,\n  EphemerisData,\n  ASPECT_ANGLES,\n  DEFAULT_ASPECT_ORBS,\n} from '@/types/astrology'\nimport { astrologyCalculator } from './calculator'\n\nexport interface TransitEvent {\n  id: string\n  transitingPlanet: Planet\n  natalPlanet: Planet\n  aspect: AspectType\n  exactDate: Date\n  startDate: Date\n  endDate: Date\n  orb: number\n  maxOrb: number\n  influence: 'major' | 'moderate' | 'minor'\n  phase: 'approaching' | 'exact' | 'separating' | 'past'\n  description: string\n  interpretation: string\n  category: 'personal' | 'social' | 'generational'\n  intensity: number // 0-100\n}\n\nexport interface TransitForecast {\n  date: Date\n  currentTransits: TransitEvent[]\n  upcomingTransits: TransitEvent[]\n  significantEvents: TransitEvent[]\n  dailyInfluences: {\n    overall: string\n    love: string\n    career: string\n    health: string\n    spirituality: string\n  }\n  lunarPhase: {\n    phase: string\n    influence: string\n    nextPhase: Date\n  }\n}\n\nexport interface TransitAlert {\n  id: string\n  type: 'exact' | 'approaching' | 'peak'\n  transit: TransitEvent\n  message: string\n  priority: 'high' | 'medium' | 'low'\n  createdAt: Date\n}\n\n/**\n * Transit Calculator for tracking planetary movements\n */\nexport class TransitCalculator {\n  private static instance: TransitCalculator\n\n  public static getInstance(): TransitCalculator {\n    if (!TransitCalculator.instance) {\n      TransitCalculator.instance = new TransitCalculator()\n    }\n    return TransitCalculator.instance\n  }\n\n  /**\n   * Calculate current transits for a birth chart\n   */\n  public async calculateCurrentTransits(\n    birthChart: BirthChart,\n    date: Date = new Date()\n  ): Promise<CalculationResult<TransitEvent[]>> {\n    const startTime = Date.now()\n\n    try {\n      // Get current planetary positions\n      const ephemerisResult = await astrologyCalculator.calculateCurrentEphemeris(date)\n      \n      if (!ephemerisResult.success || !ephemerisResult.data) {\n        throw new Error('Failed to get current ephemeris data')\n      }\n\n      const currentPositions = Object.values(ephemerisResult.data.planets)\n      const transits: TransitEvent[] = []\n\n      // Calculate transits for each current planet to each natal planet\n      for (const transitingPlanet of currentPositions) {\n        for (const natalPlanet of birthChart.planets) {\n          const transitEvents = this.calculateTransitsBetweenPlanets(\n            transitingPlanet,\n            natalPlanet,\n            date\n          )\n          transits.push(...transitEvents)\n        }\n      }\n\n      // Sort by intensity and filter significant transits\n      const significantTransits = transits\n        .filter(t => t.intensity > 30)\n        .sort((a, b) => b.intensity - a.intensity)\n\n      const calculationTime = Date.now() - startTime\n\n      return {\n        success: true,\n        data: significantTransits,\n        calculationTime,\n        accuracy: 'high',\n      }\n    } catch (error) {\n      const calculationTime = Date.now() - startTime\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown transit calculation error',\n        calculationTime,\n        accuracy: 'low',\n      }\n    }\n  }\n\n  /**\n   * Generate transit forecast for a period\n   */\n  public async generateTransitForecast(\n    birthChart: BirthChart,\n    startDate: Date = new Date(),\n    days: number = 30\n  ): Promise<CalculationResult<TransitForecast>> {\n    const startTime = Date.now()\n\n    try {\n      const currentTransitsResult = await this.calculateCurrentTransits(birthChart, startDate)\n      \n      if (!currentTransitsResult.success || !currentTransitsResult.data) {\n        throw new Error('Failed to calculate current transits')\n      }\n\n      const currentTransits = currentTransitsResult.data\n      \n      // Calculate upcoming transits\n      const upcomingTransits = await this.calculateUpcomingTransits(\n        birthChart,\n        startDate,\n        days\n      )\n\n      // Identify significant events\n      const significantEvents = [...currentTransits, ...upcomingTransits]\n        .filter(t => t.influence === 'major')\n        .sort((a, b) => a.exactDate.getTime() - b.exactDate.getTime())\n        .slice(0, 10)\n\n      // Generate daily influences\n      const dailyInfluences = this.generateDailyInfluences(currentTransits)\n\n      // Get lunar phase information\n      const lunarPhase = await this.getLunarPhaseInfluence(startDate)\n\n      const forecast: TransitForecast = {\n        date: startDate,\n        currentTransits,\n        upcomingTransits,\n        significantEvents,\n        dailyInfluences,\n        lunarPhase,\n      }\n\n      const calculationTime = Date.now() - startTime\n\n      return {\n        success: true,\n        data: forecast,\n        calculationTime,\n        accuracy: 'high',\n      }\n    } catch (error) {\n      const calculationTime = Date.now() - startTime\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown forecast calculation error',\n        calculationTime,\n        accuracy: 'low',\n      }\n    }\n  }\n\n  /**\n   * Calculate transits between two planets\n   */\n  private calculateTransitsBetweenPlanets(\n    transitingPlanet: PlanetaryPosition,\n    natalPlanet: PlanetaryPosition,\n    date: Date\n  ): TransitEvent[] {\n    const transits: TransitEvent[] = []\n    const angle = Math.abs(transitingPlanet.longitude - natalPlanet.longitude)\n    const normalizedAngle = angle > 180 ? 360 - angle : angle\n\n    for (const [aspectType, exactAngle] of Object.entries(ASPECT_ANGLES)) {\n      const maxOrb = this.getTransitOrb(transitingPlanet.planet, aspectType as AspectType)\n      const deviation = Math.abs(normalizedAngle - exactAngle)\n\n      if (deviation <= maxOrb) {\n        const transit = this.createTransitEvent(\n          transitingPlanet,\n          natalPlanet,\n          aspectType as AspectType,\n          deviation,\n          maxOrb,\n          date\n        )\n        transits.push(transit)\n      }\n    }\n\n    return transits\n  }\n\n  /**\n   * Create a transit event\n   */\n  private createTransitEvent(\n    transitingPlanet: PlanetaryPosition,\n    natalPlanet: PlanetaryPosition,\n    aspect: AspectType,\n    orb: number,\n    maxOrb: number,\n    date: Date\n  ): TransitEvent {\n    const influence = this.getTransitInfluence(transitingPlanet.planet, aspect)\n    const intensity = this.calculateTransitIntensity(transitingPlanet.planet, aspect, orb, maxOrb)\n    const phase = this.getTransitPhase(orb, maxOrb, transitingPlanet.speed)\n    const category = this.getTransitCategory(transitingPlanet.planet)\n    \n    // Calculate exact date (simplified - would use more precise calculations)\n    const exactDate = new Date(date)\n    if (orb > 0 && transitingPlanet.speed !== 0) {\n      const daysToExact = orb / Math.abs(transitingPlanet.speed)\n      exactDate.setDate(exactDate.getDate() + (transitingPlanet.speed > 0 ? daysToExact : -daysToExact))\n    }\n\n    const startDate = new Date(exactDate)\n    startDate.setDate(startDate.getDate() - Math.floor(maxOrb / Math.abs(transitingPlanet.speed || 1)))\n    \n    const endDate = new Date(exactDate)\n    endDate.setDate(endDate.getDate() + Math.floor(maxOrb / Math.abs(transitingPlanet.speed || 1)))\n\n    const description = this.getTransitDescription(transitingPlanet.planet, natalPlanet.planet, aspect)\n    const interpretation = this.getTransitInterpretation(transitingPlanet.planet, natalPlanet.planet, aspect)\n\n    return {\n      id: `${transitingPlanet.planet}-${aspect}-${natalPlanet.planet}-${date.getTime()}`,\n      transitingPlanet: transitingPlanet.planet,\n      natalPlanet: natalPlanet.planet,\n      aspect,\n      exactDate,\n      startDate,\n      endDate,\n      orb,\n      maxOrb,\n      influence,\n      phase,\n      description,\n      interpretation,\n      category,\n      intensity,\n    }\n  }\n\n  /**\n   * Get transit orb (wider than natal aspects)\n   */\n  private getTransitOrb(planet: Planet, aspect: AspectType): number {\n    const baseOrb = DEFAULT_ASPECT_ORBS[aspect]\n    \n    // Wider orbs for slower planets\n    const planetModifiers = {\n      [Planet.SUN]: 1.0,\n      [Planet.MOON]: 1.2,\n      [Planet.MERCURY]: 0.8,\n      [Planet.VENUS]: 0.8,\n      [Planet.MARS]: 0.9,\n      [Planet.JUPITER]: 1.1,\n      [Planet.SATURN]: 1.2,\n      [Planet.URANUS]: 1.0,\n      [Planet.NEPTUNE]: 1.0,\n      [Planet.PLUTO]: 1.0,\n      [Planet.NORTH_NODE]: 0.7,\n      [Planet.SOUTH_NODE]: 0.7,\n      [Planet.CHIRON]: 0.8,\n      [Planet.LILITH]: 0.6,\n    }\n\n    return baseOrb * (planetModifiers[planet] || 1.0)\n  }\n\n  /**\n   * Get transit influence level\n   */\n  private getTransitInfluence(planet: Planet, aspect: AspectType): 'major' | 'moderate' | 'minor' {\n    const majorPlanets = [Planet.SUN, Planet.MOON, Planet.JUPITER, Planet.SATURN, Planet.URANUS, Planet.NEPTUNE, Planet.PLUTO]\n    const majorAspects = ['conjunction', 'opposition', 'trine', 'square']\n    \n    if (majorPlanets.includes(planet) && majorAspects.includes(aspect)) {\n      return 'major'\n    }\n    \n    if (majorPlanets.includes(planet) || majorAspects.includes(aspect)) {\n      return 'moderate'\n    }\n    \n    return 'minor'\n  }\n\n  /**\n   * Calculate transit intensity\n   */\n  private calculateTransitIntensity(\n    planet: Planet,\n    aspect: AspectType,\n    orb: number,\n    maxOrb: number\n  ): number {\n    // Base intensity by planet\n    const planetIntensity = {\n      [Planet.SUN]: 85,\n      [Planet.MOON]: 70,\n      [Planet.MERCURY]: 50,\n      [Planet.VENUS]: 60,\n      [Planet.MARS]: 75,\n      [Planet.JUPITER]: 80,\n      [Planet.SATURN]: 90,\n      [Planet.URANUS]: 85,\n      [Planet.NEPTUNE]: 80,\n      [Planet.PLUTO]: 95,\n      [Planet.NORTH_NODE]: 60,\n      [Planet.SOUTH_NODE]: 60,\n      [Planet.CHIRON]: 65,\n      [Planet.LILITH]: 55,\n    }\n\n    // Aspect intensity modifier\n    const aspectModifier = {\n      conjunction: 1.0,\n      opposition: 0.9,\n      trine: 0.7,\n      square: 0.8,\n      sextile: 0.6,\n      quincunx: 0.5,\n      semisextile: 0.4,\n      semisquare: 0.4,\n      sesquiquadrate: 0.4,\n      quintile: 0.3,\n      biquintile: 0.3,\n    }\n\n    // Orb modifier (closer = stronger)\n    const orbModifier = 1 - (orb / maxOrb)\n\n    const baseIntensity = planetIntensity[planet] || 50\n    const modifier = (aspectModifier[aspect] || 0.5) * orbModifier\n\n    return Math.round(baseIntensity * modifier)\n  }\n\n  /**\n   * Get transit phase\n   */\n  private getTransitPhase(\n    orb: number,\n    maxOrb: number,\n    speed: number\n  ): 'approaching' | 'exact' | 'separating' | 'past' {\n    if (orb <= 0.5) return 'exact'\n    if (orb > maxOrb) return 'past'\n    \n    // Simplified phase calculation based on speed direction\n    return speed > 0 ? 'approaching' : 'separating'\n  }\n\n  /**\n   * Get transit category\n   */\n  private getTransitCategory(planet: Planet): 'personal' | 'social' | 'generational' {\n    const personalPlanets = [Planet.SUN, Planet.MOON, Planet.MERCURY, Planet.VENUS, Planet.MARS]\n    const socialPlanets = [Planet.JUPITER, Planet.SATURN]\n    \n    if (personalPlanets.includes(planet)) return 'personal'\n    if (socialPlanets.includes(planet)) return 'social'\n    return 'generational'\n  }\n\n  /**\n   * Calculate upcoming transits\n   */\n  private async calculateUpcomingTransits(\n    birthChart: BirthChart,\n    startDate: Date,\n    days: number\n  ): Promise<TransitEvent[]> {\n    const upcomingTransits: TransitEvent[] = []\n    \n    // Simplified calculation - in production, would calculate for each day\n    for (let i = 1; i <= days; i++) {\n      const futureDate = new Date(startDate)\n      futureDate.setDate(futureDate.getDate() + i)\n      \n      const transitsResult = await this.calculateCurrentTransits(birthChart, futureDate)\n      if (transitsResult.success && transitsResult.data) {\n        upcomingTransits.push(...transitsResult.data.filter(t => t.phase === 'approaching'))\n      }\n    }\n    \n    // Remove duplicates and sort by date\n    const uniqueTransits = upcomingTransits.filter((transit, index, self) => \n      index === self.findIndex(t => t.id === transit.id)\n    )\n    \n    return uniqueTransits.sort((a, b) => a.exactDate.getTime() - b.exactDate.getTime())\n  }\n\n  /**\n   * Generate daily influences\n   */\n  private generateDailyInfluences(transits: TransitEvent[]) {\n    const influences = {\n      overall: 'A day of balanced energies with opportunities for growth.',\n      love: 'Relationships benefit from open communication and understanding.',\n      career: 'Professional matters require steady focus and determination.',\n      health: 'Pay attention to your body\\'s needs and maintain balance.',\n      spirituality: 'A good time for reflection and inner exploration.'\n    }\n\n    // Customize based on active transits\n    const majorTransits = transits.filter(t => t.influence === 'major')\n    \n    if (majorTransits.length > 0) {\n      influences.overall = 'Significant planetary influences are active today, bringing both opportunities and challenges.'\n    }\n\n    return influences\n  }\n\n  /**\n   * Get lunar phase influence\n   */\n  private async getLunarPhaseInfluence(date: Date) {\n    const lunarPhase = astrologyCalculator.calculateLunarPhase(date)\n    \n    const phaseInfluences = {\n      new: 'A time for new beginnings and setting intentions.',\n      waxing_crescent: 'Energy is building - take action on your goals.',\n      first_quarter: 'Challenges may arise, but persistence pays off.',\n      waxing_gibbous: 'Refinement and adjustment lead to success.',\n      full: 'Peak energy and emotions - time for completion and release.',\n      waning_gibbous: 'Gratitude and sharing wisdom with others.',\n      last_quarter: 'Release what no longer serves you.',\n      waning_crescent: 'Rest, reflect, and prepare for the next cycle.'\n    }\n\n    const nextPhase = new Date(date)\n    nextPhase.setDate(nextPhase.getDate() + 7) // Simplified - would calculate actual next phase\n\n    return {\n      phase: lunarPhase.phase,\n      influence: phaseInfluences[lunarPhase.phase] || 'A time of transition and change.',\n      nextPhase\n    }\n  }\n\n  /**\n   * Get transit description\n   */\n  private getTransitDescription(transitingPlanet: Planet, natalPlanet: Planet, aspect: AspectType): string {\n    return `${transitingPlanet} ${aspect} natal ${natalPlanet}`\n  }\n\n  /**\n   * Get transit interpretation\n   */\n  private getTransitInterpretation(transitingPlanet: Planet, natalPlanet: Planet, aspect: AspectType): string {\n    // Simplified interpretations - in production, would have comprehensive database\n    const interpretations = {\n      [`${Planet.JUPITER}_trine_${Planet.SUN}`]: 'A fortunate time for expansion, confidence, and new opportunities. Your natural talents shine brightly.',\n      [`${Planet.SATURN}_square_${Planet.MOON}`]: 'Emotional challenges require patience and maturity. Focus on building stronger foundations.',\n      [`${Planet.MARS}_conjunction_${Planet.VENUS}`]: 'Passion and desire are heightened. Excellent for romance and creative pursuits.',\n      [`${Planet.URANUS}_opposition_${Planet.MERCURY}`]: 'Unexpected communications and sudden insights. Be open to new perspectives.',\n      [`${Planet.NEPTUNE}_sextile_${Planet.JUPITER}`]: 'Spiritual growth and expanded consciousness. Trust your intuition and dreams.'\n    }\n\n    const key = `${transitingPlanet}_${aspect}_${natalPlanet}`\n    return interpretations[key] || `${transitingPlanet} ${aspect} ${natalPlanet} brings significant energy to your life.`\n  }\n}\n\n// Export singleton instance\nexport const transitCalculator = TransitCalculator.getInstance()"