/**\n * Supabase Authentication and Database Integration\n * Handles user authentication, profiles, and social features\n */\n\nimport { createClient } from '@supabase/supabase-js'\nimport { BirthChart, BirthData } from '@/types/astrology'\n\n// Supabase configuration\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey)\n\n// Database Types\nexport interface UserProfile {\n  id: string\n  email: string\n  username: string\n  display_name: string\n  avatar_url?: string\n  bio?: string\n  location?: string\n  website?: string\n  birth_data?: BirthData\n  privacy_settings: {\n    show_birth_chart: boolean\n    show_birth_data: boolean\n    allow_friend_requests: boolean\n    show_online_status: boolean\n  }\n  astrology_level: 'beginner' | 'intermediate' | 'advanced' | 'professional'\n  completed_courses: string[]\n  certificates: string[]\n  created_at: string\n  updated_at: string\n}\n\nexport interface SavedChart {\n  id: string\n  user_id: string\n  name: string\n  description?: string\n  birth_data: BirthData\n  chart_data: BirthChart\n  is_public: boolean\n  tags: string[]\n  created_at: string\n  updated_at: string\n}\n\nexport interface ChartShare {\n  id: string\n  chart_id: string\n  shared_by: string\n  shared_with?: string // null for public shares\n  share_type: 'public' | 'friends' | 'specific'\n  message?: string\n  expires_at?: string\n  created_at: string\n}\n\nexport interface Friendship {\n  id: string\n  requester_id: string\n  addressee_id: string\n  status: 'pending' | 'accepted' | 'blocked'\n  created_at: string\n  updated_at: string\n}\n\nexport interface CommunityPost {\n  id: string\n  user_id: string\n  content: string\n  post_type: 'text' | 'chart_share' | 'question' | 'interpretation'\n  chart_id?: string\n  tags: string[]\n  likes_count: number\n  comments_count: number\n  is_featured: boolean\n  created_at: string\n  updated_at: string\n}\n\nexport interface PostComment {\n  id: string\n  post_id: string\n  user_id: string\n  content: string\n  parent_comment_id?: string\n  likes_count: number\n  created_at: string\n  updated_at: string\n}\n\nexport interface PostLike {\n  id: string\n  post_id: string\n  user_id: string\n  created_at: string\n}\n\nexport interface AstrologyGroup {\n  id: string\n  name: string\n  description: string\n  avatar_url?: string\n  cover_url?: string\n  created_by: string\n  group_type: 'public' | 'private' | 'secret'\n  member_count: number\n  tags: string[]\n  rules?: string[]\n  created_at: string\n  updated_at: string\n}\n\nexport interface GroupMembership {\n  id: string\n  group_id: string\n  user_id: string\n  role: 'member' | 'moderator' | 'admin'\n  joined_at: string\n}\n\n/**\n * Authentication Service\n */\nexport class AuthService {\n  private static instance: AuthService\n\n  public static getInstance(): AuthService {\n    if (!AuthService.instance) {\n      AuthService.instance = new AuthService()\n    }\n    return AuthService.instance\n  }\n\n  /**\n   * Sign up with email and password\n   */\n  async signUp(email: string, password: string, userData: Partial<UserProfile>) {\n    try {\n      const { data, error } = await supabase.auth.signUp({\n        email,\n        password,\n        options: {\n          data: {\n            username: userData.username,\n            display_name: userData.display_name,\n          }\n        }\n      })\n\n      if (error) throw error\n\n      // Create user profile\n      if (data.user) {\n        await this.createUserProfile(data.user.id, {\n          email,\n          username: userData.username!,\n          display_name: userData.display_name!,\n          bio: userData.bio,\n          location: userData.location,\n          privacy_settings: {\n            show_birth_chart: true,\n            show_birth_data: false,\n            allow_friend_requests: true,\n            show_online_status: true,\n          },\n          astrology_level: 'beginner',\n          completed_courses: [],\n          certificates: [],\n        })\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Sign in with email and password\n   */\n  async signIn(email: string, password: string) {\n    try {\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      })\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Sign out\n   */\n  async signOut() {\n    try {\n      const { error } = await supabase.auth.signOut()\n      return { error }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Get current user\n   */\n  async getCurrentUser() {\n    try {\n      const { data: { user }, error } = await supabase.auth.getUser()\n      return { user, error }\n    } catch (error) {\n      return { user: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Create user profile\n   */\n  private async createUserProfile(userId: string, profileData: Omit<UserProfile, 'id' | 'created_at' | 'updated_at'>) {\n    const { data, error } = await supabase\n      .from('user_profiles')\n      .insert({\n        id: userId,\n        ...profileData,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      })\n      .select()\n      .single()\n\n    if (error) throw error\n    return data\n  }\n\n  /**\n   * Update user profile\n   */\n  async updateUserProfile(userId: string, updates: Partial<UserProfile>) {\n    try {\n      const { data, error } = await supabase\n        .from('user_profiles')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', userId)\n        .select()\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get user profile\n   */\n  async getUserProfile(userId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('user_profiles')\n        .select('*')\n        .eq('id', userId)\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Search users\n   */\n  async searchUsers(query: string, limit: number = 20) {\n    try {\n      const { data, error } = await supabase\n        .from('user_profiles')\n        .select('id, username, display_name, avatar_url, bio, astrology_level')\n        .or(`username.ilike.%${query}%,display_name.ilike.%${query}%`)\n        .limit(limit)\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n}\n\n/**\n * Chart Management Service\n */\nexport class ChartService {\n  private static instance: ChartService\n\n  public static getInstance(): ChartService {\n    if (!ChartService.instance) {\n      ChartService.instance = new ChartService()\n    }\n    return ChartService.instance\n  }\n\n  /**\n   * Save a birth chart\n   */\n  async saveChart(userId: string, chartData: Omit<SavedChart, 'id' | 'user_id' | 'created_at' | 'updated_at'>) {\n    try {\n      const { data, error } = await supabase\n        .from('saved_charts')\n        .insert({\n          user_id: userId,\n          ...chartData,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .select()\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get user's saved charts\n   */\n  async getUserCharts(userId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('saved_charts')\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false })\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get public charts\n   */\n  async getPublicCharts(limit: number = 20, offset: number = 0) {\n    try {\n      const { data, error } = await supabase\n        .from('saved_charts')\n        .select(`\n          *,\n          user_profiles!inner(\n            username,\n            display_name,\n            avatar_url\n          )\n        `)\n        .eq('is_public', true)\n        .order('created_at', { ascending: false })\n        .range(offset, offset + limit - 1)\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Share a chart\n   */\n  async shareChart(chartId: string, sharedBy: string, shareData: Omit<ChartShare, 'id' | 'chart_id' | 'shared_by' | 'created_at'>) {\n    try {\n      const { data, error } = await supabase\n        .from('chart_shares')\n        .insert({\n          chart_id: chartId,\n          shared_by: sharedBy,\n          ...shareData,\n          created_at: new Date().toISOString(),\n        })\n        .select()\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Delete a chart\n   */\n  async deleteChart(chartId: string, userId: string) {\n    try {\n      const { error } = await supabase\n        .from('saved_charts')\n        .delete()\n        .eq('id', chartId)\n        .eq('user_id', userId)\n\n      return { error }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n}\n\n/**\n * Social Features Service\n */\nexport class SocialService {\n  private static instance: SocialService\n\n  public static getInstance(): SocialService {\n    if (!SocialService.instance) {\n      SocialService.instance = new SocialService()\n    }\n    return SocialService.instance\n  }\n\n  /**\n   * Send friend request\n   */\n  async sendFriendRequest(requesterId: string, addresseeId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('friendships')\n        .insert({\n          requester_id: requesterId,\n          addressee_id: addresseeId,\n          status: 'pending',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .select()\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Accept friend request\n   */\n  async acceptFriendRequest(friendshipId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('friendships')\n        .update({\n          status: 'accepted',\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', friendshipId)\n        .select()\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get user's friends\n   */\n  async getUserFriends(userId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('friendships')\n        .select(`\n          *,\n          requester:user_profiles!requester_id(\n            id, username, display_name, avatar_url\n          ),\n          addressee:user_profiles!addressee_id(\n            id, username, display_name, avatar_url\n          )\n        `)\n        .or(`requester_id.eq.${userId},addressee_id.eq.${userId}`)\n        .eq('status', 'accepted')\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get pending friend requests\n   */\n  async getPendingRequests(userId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('friendships')\n        .select(`\n          *,\n          requester:user_profiles!requester_id(\n            id, username, display_name, avatar_url\n          )\n        `)\n        .eq('addressee_id', userId)\n        .eq('status', 'pending')\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n}\n\n/**\n * Community Service\n */\nexport class CommunityService {\n  private static instance: CommunityService\n\n  public static getInstance(): CommunityService {\n    if (!CommunityService.instance) {\n      CommunityService.instance = new CommunityService()\n    }\n    return CommunityService.instance\n  }\n\n  /**\n   * Create a community post\n   */\n  async createPost(userId: string, postData: Omit<CommunityPost, 'id' | 'user_id' | 'likes_count' | 'comments_count' | 'created_at' | 'updated_at'>) {\n    try {\n      const { data, error } = await supabase\n        .from('community_posts')\n        .insert({\n          user_id: userId,\n          ...postData,\n          likes_count: 0,\n          comments_count: 0,\n          is_featured: false,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .select()\n        .single()\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get community feed\n   */\n  async getCommunityFeed(limit: number = 20, offset: number = 0) {\n    try {\n      const { data, error } = await supabase\n        .from('community_posts')\n        .select(`\n          *,\n          user_profiles!inner(\n            username,\n            display_name,\n            avatar_url,\n            astrology_level\n          ),\n          saved_charts(\n            name,\n            description,\n            birth_data\n          )\n        `)\n        .order('created_at', { ascending: false })\n        .range(offset, offset + limit - 1)\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Like a post\n   */\n  async likePost(postId: string, userId: string) {\n    try {\n      // Check if already liked\n      const { data: existingLike } = await supabase\n        .from('post_likes')\n        .select('id')\n        .eq('post_id', postId)\n        .eq('user_id', userId)\n        .single()\n\n      if (existingLike) {\n        // Unlike\n        await supabase\n          .from('post_likes')\n          .delete()\n          .eq('post_id', postId)\n          .eq('user_id', userId)\n\n        // Decrement likes count\n        await supabase.rpc('decrement_post_likes', { post_id: postId })\n      } else {\n        // Like\n        await supabase\n          .from('post_likes')\n          .insert({\n            post_id: postId,\n            user_id: userId,\n            created_at: new Date().toISOString(),\n          })\n\n        // Increment likes count\n        await supabase.rpc('increment_post_likes', { post_id: postId })\n      }\n\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Add comment to post\n   */\n  async addComment(postId: string, userId: string, content: string, parentCommentId?: string) {\n    try {\n      const { data, error } = await supabase\n        .from('post_comments')\n        .insert({\n          post_id: postId,\n          user_id: userId,\n          content,\n          parent_comment_id: parentCommentId,\n          likes_count: 0,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .select()\n        .single()\n\n      if (!error) {\n        // Increment comments count\n        await supabase.rpc('increment_post_comments', { post_id: postId })\n      }\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n\n  /**\n   * Get post comments\n   */\n  async getPostComments(postId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('post_comments')\n        .select(`\n          *,\n          user_profiles!inner(\n            username,\n            display_name,\n            avatar_url\n          )\n        `)\n        .eq('post_id', postId)\n        .order('created_at', { ascending: true })\n\n      return { data, error }\n    } catch (error) {\n      return { data: null, error: error as Error }\n    }\n  }\n}\n\n// Export service instances\nexport const authService = AuthService.getInstance()\nexport const chartService = ChartService.getInstance()\nexport const socialService = SocialService.getInstance()\nexport const communityService = CommunityService.getInstance()"